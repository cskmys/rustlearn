== An I/O Project: Building a Command Line Program

In this project we build our own version of the command line tool `grep` that interacts with file and command line io.
[NOTE]
====
`grep` stands for *g*-lobally search a *r*-egular *e*-xpression and *p*-rint.
In the simplest of the use cases, it takes as its arguments a filename and a string, reads the file, searches for the lines that contain a specified string and prints those lines.
====

[IMPORTANT]
====
*To follow this section follow the git history to follow the code evolution and the notes in the comments*
====

=== Accepting Command Line Arguments

==== Reading the argument values
`std::env::args()` is used to read the command line arguments.
It will panic if unicode values are entered.
For taking unicode input you can use `std::env::args_os`, which returns `OsString`, whose values differ based on the OS, instead of `String`.
For the sake of simplicity we choose to not deal with unicode at the moment.

==== Saving the argument values in variables
Using `collect` on `std::env::args()` turns the iterator returned by it into a vector of all the command line arguments produced by it.

=== Reading a file
`std::fs::read_to_string(file_name)` is used to read the file.
It takes in a filename, opens the file, reads its contents and returns them as `Result<String>` meaning, upon success you'll get `Ok(String)` and on failure you'll get `Err(String)`.

=== Refactoring to improve Modularity and Error Handling
[IMPORTANT]
====
Make code changes in small units and continuously execute to check for correctness.
====
[TIP]
====
On the first pass always go for the simplest implementation.
Resist the strong temptation to pre-optimize i.e. do not try to write hyper-optimized code on your first pass.
====

==== Separation of concerns for binary projects
In a binary project programmers tend to write multiple tasks within the `main` function.
As the project grows large this can be problematic.
Rust community recommends splitting your program into a `main.rs` & `lib.rs` and move your program logic to `lib.rs`

The `main` function should be limited to performing:

* Parsing command line arguments
+
[NOTE]
====
If command line parsing logic is small you can keep it in `main.rs` otherwise move it to `lib.rs`
====
* Setting up any other configuration
* Calling a `run` function in `lib.rs`
* Handling the error if `run` returns an error

This way you can test all the code that gets called from `main` function thoroughly and the code within the `main` function will be small enough to verify its correctness by just reading it.

===== Extracting the argument parser
Move the argument parsing logic in the `main` function to another function within `main.rs` or `lib.rs` depending on the length of parsing logic

===== Grouping configuration values
After parsing the arguments you can group the configuration values under a `Config` struct.
[TIP]
====
* Whenever you are returning a tuple from a function, if they are related to same function then it is meaningful to group them together under a struct

* It is ok to trade a little performance to gain code simplicity and readability.

* Don't be obsessed with primitive data types and be open to using complex data types when you can make gains in terms of code simplicity, scalability or readability.
====

===== Creating a constructor for `Config`
If all that your parsing function is doing is creating an instance of your `Config` struct, then you can delete this function and move all the logic inside it to a constructor of `Config` struct.

==== Fixing the Error Handling
After setting up the minimal working logic, move to handling errors.

===== Improving the Error message
Write your own error messages and cause panic upon errors everywhere.

===== Returning a `Result<T, E>` instead of `panic!`
Now wherever appropriate you can selectively change panics to returning `Result<T, E>`.

===== Handle `Result<T, E>`
You can use `unwrap` and similar methods to get the value upon success and error return upon failure.
[TIP]
====
Using `unwrap` means you'll need to do pattern matching, instead you can `unwrap_or_else` which behaves same as `unwrap` during success and allows you to write a code in closure upon failure.
====
Wherever you want to exit the program upon error you can use `std::process::exit`.

==== Extracting logic from `main`
Move all the post configuration program logic into a function called `run`.